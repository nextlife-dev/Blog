---
title: 기본적인 코드 문법 이해
description: 
aliases:
  - Seungwoo Ham
tags:
  - document
date: 2025-01-17
---
```cpp
#include <iostream>
//#include <cstdio> //cstyle
using namespace std;

int main(){
  cout << "Hello, World!" << endl;
  //printf("Hello, World!\n"); //cstyle

  return 0;
}
```

## 전처리 지시자

C++에서 함수를 사용하고자 한다면 **반드시 그 함수의 원형을 미리 정의하여야 합니다.** 하지만 `cout`를 정의하지 않았는데도 사용할 수 있는 이유는 `#include <iostream>` 전처리 지시자 덕분입니다.

전처리 지시자는 컴파일 단계에서 코드를 변형하는 특수 명령어이며,  
라이브러리와 모듈 같은 집합이나 단위가 아니라, **컴파일러가 코드를 분석하기 전에 실행됩니다.** 즉, 실제 코드 실행과는 별개로 작동되며, 코드의 구조나 동작을 변경하는 역할을 합니다.

만약 전처리 지시자를 사용하지 않으면, `cout`, `endl`과 같은 표준 라이브러리 요소들을 일반적인 함수처럼 정의하고 사용하는 것은 불가능합니다.

## 네임스페이스

이름 충돌을 방지하기 위해 코드를 논리적으로 분류하는 공간입니다.

`std` 네임스페이스는 C++ 표준 라이브러리에 속한 요소들을 포함합니다: `cout`, `cin`, `string` …

`using namespace std;`를 사용하면 `std::` 접두사 없이도 `std` 네임스페이스의 요소들을 직접 사용할 수 있습니다:

```cpp
// using namespace std; 를 사용하는 경우 
cout << "Hello, world!" << endl; 

// using namespace std; 를 사용하지 않는 경우 
std::cout << "Hello, world!" << std::endl;
```

일반적으로는 `using namespace std;` 대신 필요한 요소만 명시적으로 사용하도록 하는 것이 좋습니다. 만약 사용자가 정의한 함수나 변수의 이름이 `std` 네임스페이스에 있는 요소와 동일하다면, **컴파일 오류가 발생할 수 있기 때문입니다.**

## 공용체 union & 구조체 struct

사용자 정의 데이터 타입을 생성하는 데 사용되지만, **메모리 할당 방식과 용도에 있어 중요한 차이가 있습니다.**

### 구조체

여러 데이터 타입을 하나로 묶어 세로운 데이터 타입을 정의합니다:

```cpp
struct Student {
    string name;
    int age;
    double gpa;
};
```

각 멤버 변수는 ==고유한 메모리 공간을 할당 받습니다.== 따라서 모든 멤버에 동시에 접근할 수 있습니다. 단, 구조체의 크기는 일반적으로 모든 멤버 변수 크기의 합과 같거나 그보다 큽니다. (패딩으로 인해)

### 공용체

여러 데이터 타입을 같은 메모리 공간에 할당합니다.

```cpp
union Data {
    int i;
    float f;
    char str[20];
};
```

모든 멤버가 ==같은 메모리 공간을 공유합니다.== 따라서 한 번에 하나의 멤버만 유효한 값을 가집니다. 그러므로, 공용체의 크기는 가장 큰 멤버의 크기와 같습니다.

## 열거체 enum

명명된 상수들의 집합을 정의하며, 코드의 가독성과 유지보수성을 향상시킵니다. 또한, 열거형의 개수와 상관없이 4바이트의 고정된 크기를 가집니다.

```cpp
enum spectrum {
	red, orange, yellow, green, blue, violet, indigo, ultraviolet
	// 0, 1, 2, 3, 4, 5, 6, 7
}
```

열거자(red, orange …)들은 기본적으로 0부터 시작하여 1씩 증가하는 정수 값을 가집니다.  
또는 명시적으로 할당할 수도 있습니다:

```cpp
enum PlayerState { IDLE = 1, WALK, RUN, ATTACK, DEAD, END };
```

이때 `PlayerState a = WALK;`으로 `a` 값을 불러오면, 2라는 숫자가 출력됩니다.

더 나아가, `PlayerState`라는 열거체 타입에 열거자를 대입할 수 있지만, 산술연산은 허용되지 않습니다. 다만, `int b = blue + 3`와 같은 형식으로는 됩니다.

### enum class 도입

기존 열거체의 몇 가지 단점을 보완합니다:

```cpp
enum class Color { RED, GREEN, BLUE };
```

열거자는 열거체 이름으로 한정되어야 하며 (`Color c = Color::RED;`), 다른 타입으로의 암시적 변환이 불가능해집니다. 또한, 서로 다른 `enum class`에서 같은 이름의 열거자를 사용할 수 있죠.

## new 연산자

[C++ Learn: new 연산자](https://learn.microsoft.com/ko-kr/cpp/cpp/new-operator-cpp?view=msvc-170)

Java:

```java
Integer num = new Integer(5); // 또는 그냥 Integer num = 5;
```

C++:

```cpp
int* pointer = new int;  // 힙 메모리에 정수형 공간 할당
*pointer = 5;  // 값 할당
```

Java는 가비지 컬렉터가 자동으로 메모리를 관리하지만, C++에서는 `delete pointer;`로 직접 메모리를 해제해줘야 합니다.

Java에서는 기본 타입(primitive type)을 제외한 모든 것이 참조(reference)인 반면, C++는 스택에 직접 객체를 만들 수도 있고 힙에 동적으로 할당할 수도 있습니다.

Java의 참조는 포인터와 비슷하지만, 직접적인 메모리 조작은 불가능합니다. C++의 포인터는 메모리 주소를 직접 다룰 수 있죠.

그래서 개념적으로는 비슷하다고 볼 수 있지만, 실제 동작 방식과 메모리 관리 측면에서는 꽤 다릅니다.

## delete 연산자

[C++ Learn: delete 연산자](https://learn.microsoft.com/ko-kr/cpp/cpp/delete-operator-cpp?view=msvc-170)

사용한 메모리를 다시 메모리 pool로 환수하며, 환수된 메모리는 프로그램의 다른 부분이 다시 사용됩니다.

여기에 4가지 규칙이 있습니다:

1. `new`로 대입하지 않은 메모리는 `delete`로 해제할 수 없으며,
2. 같은 메모리 블록을 연달아 두 번 `delete`로 해제할 수 없으며,
3. `new[]`로 메모리를 대입할 경우 `delete[]`로 해제하며,
4. 대괄호를 사용하지 않았다면 `delete`도 대괄호를 사용하지 않아야 합니다.

## stack 메모리와 heap 메모리 해제 방식

```cpp
// 스택 메모리 할당 - delete 불가능
int i = 1;
char c = 'A';
double d = 3.14;

// 힙 메모리 할당 - delete 가능
int* pi = new int;
char* pc = new char;
double* pd = new double;

// 이후 힙 메모리 해제
delete pi;
delete pc;
delete pd;
```

기본 데이터 타입이라도 `new`를 통해 ==힙에 동적으로 할당된 경우에만== `delete`로 해제가 가능합니다.

스택에 할당된 변수는 scope를 벗어나면 ==자동으로 해제되므로== 별도의 `delete`가 필요하지 않습니다.